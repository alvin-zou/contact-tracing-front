{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"/Users/mosesmayer/Desktop/Harvard/Summer 2020/Personal-Projects/Contact Tracing/contact-tracing-front/node_modules/react-native-pie-chart/src/Wedge.js\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { ART } from \"react-native-web/dist/index\";\nimport PropTypes from 'prop-types';\nvar Shape = ART.Shape,\n    Path = ART.Path;\n\nvar Wedge = function (_Component) {\n  _inherits(Wedge, _Component);\n\n  var _super = _createSuper(Wedge);\n\n  function Wedge(props) {\n    var _this;\n\n    _classCallCheck(this, Wedge);\n\n    _this = _super.call(this, props);\n    _this.circleRadians = Math.PI * 2;\n    _this.radiansPerDegree = Math.PI / 180;\n    _this._degreesToRadians = _this._degreesToRadians.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(Wedge, [{\n    key: \"_degreesToRadians\",\n    value: function _degreesToRadians(degrees) {\n      if (degrees !== 0 && degrees % 360 === 0) {\n        return this.circleRadians;\n      }\n\n      return degrees * this.radiansPerDegree % this.circleRadians;\n    }\n  }, {\n    key: \"_createCirclePath\",\n    value: function _createCirclePath(or, ir) {\n      var path = new Path();\n      path.move(0, or).arc(or * 2, 0, or).arc(-or * 2, 0, or);\n\n      if (ir) {\n        path.move(or - ir, 0).counterArc(ir * 2, 0, ir).counterArc(-ir * 2, 0, ir);\n      }\n\n      path.close();\n      return path;\n    }\n  }, {\n    key: \"_createArcPath\",\n    value: function _createArcPath(startAngle, endAngle, or, ir) {\n      var path = new Path();\n\n      var sa = this._degreesToRadians(startAngle);\n\n      var ea = this._degreesToRadians(endAngle);\n\n      var ca = sa > ea ? this.circleRadians - sa + ea : ea - sa;\n      var ss = Math.sin(sa);\n      var es = Math.sin(ea);\n      var sc = Math.cos(sa);\n      var ec = Math.cos(ea);\n      var ds = es - ss;\n      var dc = ec - sc;\n      var dr = ir - or;\n      var large = ca > Math.PI;\n      var ARC = 4;\n      var CIRCLE_X = or;\n      var CIRCLE_Y = or;\n      var RX = or - or / 2;\n      var TwoPI = 2 * Math.PI;\n\n      if (Platform.OS === 'ios' || startAngle === 0 && endAngle == 360) {\n        path.move(or + or * ss, or - or * sc).arc(or * ds, or * -dc, or, or, large).line(dr * es, dr * -ec);\n      } else {\n        path.path.push(ARC, CIRCLE_X, CIRCLE_Y, RX, startAngle / 360 * TwoPI, startAngle / 360 * TwoPI - (endAngle - startAngle) / 360 * TwoPI, 0);\n      }\n\n      if (ir) {\n        path.counterArc(ir * -ds, ir * dc, ir, ir, large);\n      }\n\n      return path;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var startAngle = this.props.startAngle;\n      var endAngle = this.props.endAngle;\n\n      if (startAngle - endAngle === 0) {\n        return;\n      }\n\n      var innerRadius = this.props.innerRadius || 0;\n      var outerRadius = this.props.outerRadius;\n      var ir = Math.min(innerRadius, outerRadius);\n      var or = Math.max(innerRadius, outerRadius);\n      var path;\n\n      if (endAngle >= startAngle + 360) {\n        path = this._createCirclePath(or, ir);\n      } else {\n        path = this._createArcPath(startAngle, endAngle, or, ir);\n      }\n\n      if (Platform.OS === 'ios' || startAngle === 0 && endAngle == 360) {\n        return React.createElement(Shape, _extends({}, this.props, {\n          d: path,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 180,\n            columnNumber: 14\n          }\n        }));\n      } else {\n        var size = this.props.outerRadius * 2;\n        var cx = cy = size / 2;\n        var p = Path();\n        p.path.push(0, cx, cy);\n        p.path.push(4, cx, cy, outerRadius, startAngle * Math.PI / 180, endAngle * Math.PI / 180, 1);\n        return React.createElement(Shape, {\n          d: p,\n          fill: this.props.fill,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 187,\n            columnNumber: 14\n          }\n        });\n      }\n    }\n  }]);\n\n  return Wedge;\n}(Component);\n\nWedge.propTypes = {\n  outerRadius: PropTypes.number.isRequired,\n  startAngle: PropTypes.number.isRequired,\n  endAngle: PropTypes.number.isRequired,\n  innerRadius: PropTypes.number\n};\nexport default Wedge;","map":{"version":3,"sources":["/Users/mosesmayer/Desktop/Harvard/Summer 2020/Personal-Projects/Contact Tracing/contact-tracing-front/node_modules/react-native-pie-chart/src/Wedge.js"],"names":["React","Component","ART","PropTypes","Shape","Path","Wedge","props","circleRadians","Math","PI","radiansPerDegree","_degreesToRadians","bind","degrees","or","ir","path","move","arc","counterArc","close","startAngle","endAngle","sa","ea","ca","ss","sin","es","sc","cos","ec","ds","dc","dr","large","ARC","CIRCLE_X","CIRCLE_Y","RX","TwoPI","Platform","OS","line","push","innerRadius","outerRadius","min","max","_createCirclePath","_createArcPath","size","cx","cy","p","fill","propTypes","number","isRequired"],"mappings":";;;;;;;;;;;;;AAwBA,OAAOA,KAAP,IAAeC,SAAf,QAA+B,OAA/B;;SACkBC,G;AAClB,OAAOC,SAAP,MAAsB,YAAtB;IACOC,K,GAAeF,G,CAAfE,K;IAAOC,I,GAAQH,G,CAARG,I;;IAMRC,K;;;;;AACJ,iBAAYC,KAAZ,EAAmB;AAAA;;AAAA;;AACjB,8BAAMA,KAAN;AACA,UAAKC,aAAL,GAAqBC,IAAI,CAACC,EAAL,GAAU,CAA/B;AACA,UAAKC,gBAAL,GAAwBF,IAAI,CAACC,EAAL,GAAU,GAAlC;AACA,UAAKE,iBAAL,GAAyB,MAAKA,iBAAL,CAAuBC,IAAvB,+BAAzB;AAJiB;AAKlB;;;;sCASiBC,O,EAAS;AACzB,UAAIA,OAAO,KAAK,CAAZ,IAAiBA,OAAO,GAAG,GAAV,KAAkB,CAAvC,EAA0C;AACxC,eAAO,KAAKN,aAAZ;AACD;;AACD,aAAOM,OAAO,GAAG,KAAKH,gBAAf,GAAkC,KAAKH,aAA9C;AACD;;;sCAUiBO,E,EAAIC,E,EAAI;AACxB,UAAMC,IAAI,GAAG,IAAIZ,IAAJ,EAAb;AAEAY,MAAAA,IAAI,CAACC,IAAL,CAAU,CAAV,EAAaH,EAAb,EAAiBI,GAAjB,CAAqBJ,EAAE,GAAG,CAA1B,EAA6B,CAA7B,EAAgCA,EAAhC,EAAoCI,GAApC,CAAwC,CAACJ,EAAD,GAAM,CAA9C,EAAiD,CAAjD,EAAoDA,EAApD;;AAEA,UAAIC,EAAJ,EAAQ;AACNC,QAAAA,IAAI,CAACC,IAAL,CAAUH,EAAE,GAAGC,EAAf,EAAmB,CAAnB,EAAsBI,UAAtB,CAAiCJ,EAAE,GAAG,CAAtC,EAAyC,CAAzC,EAA4CA,EAA5C,EAAgDI,UAAhD,CAA2D,CAACJ,EAAD,GAAM,CAAjE,EAAoE,CAApE,EAAuEA,EAAvE;AACD;;AAEDC,MAAAA,IAAI,CAACI,KAAL;AAEA,aAAOJ,IAAP;AACD;;;mCAYcK,U,EAAYC,Q,EAAUR,E,EAAIC,E,EAAI;AAC3C,UAAMC,IAAI,GAAG,IAAIZ,IAAJ,EAAb;;AAGA,UAAMmB,EAAE,GAAG,KAAKZ,iBAAL,CAAuBU,UAAvB,CAAX;;AACA,UAAMG,EAAE,GAAG,KAAKb,iBAAL,CAAuBW,QAAvB,CAAX;;AAGA,UAAMG,EAAE,GAAGF,EAAE,GAAGC,EAAL,GACL,KAAKjB,aAAL,GAAqBgB,EAArB,GAA0BC,EADrB,GAELA,EAAE,GAAGD,EAFX;AAKA,UAAMG,EAAE,GAAGlB,IAAI,CAACmB,GAAL,CAASJ,EAAT,CAAX;AACA,UAAMK,EAAE,GAAGpB,IAAI,CAACmB,GAAL,CAASH,EAAT,CAAX;AACA,UAAMK,EAAE,GAAGrB,IAAI,CAACsB,GAAL,CAASP,EAAT,CAAX;AACA,UAAMQ,EAAE,GAAGvB,IAAI,CAACsB,GAAL,CAASN,EAAT,CAAX;AAGA,UAAMQ,EAAE,GAAGJ,EAAE,GAAGF,EAAhB;AACA,UAAMO,EAAE,GAAGF,EAAE,GAAGF,EAAhB;AACA,UAAMK,EAAE,GAAGnB,EAAE,GAAGD,EAAhB;AAIA,UAAMqB,KAAK,GAAGV,EAAE,GAAGjB,IAAI,CAACC,EAAxB;AAuBA,UAAM2B,GAAG,GAAG,CAAZ;AACA,UAAMC,QAAQ,GAAGvB,EAAjB;AACA,UAAMwB,QAAQ,GAAGxB,EAAjB;AACA,UAAMyB,EAAE,GAAGzB,EAAE,GAAGA,EAAE,GAAG,CAArB;AACA,UAAM0B,KAAK,GAAG,IAAIhC,IAAI,CAACC,EAAvB;;AAEA,UAAIgC,QAAQ,CAACC,EAAT,KAAgB,KAAhB,IAA0BrB,UAAU,KAAK,CAAf,IAAoBC,QAAQ,IAAI,GAA9D,EAAoE;AAClEN,QAAAA,IAAI,CAACC,IAAL,CAAUH,EAAE,GAAGA,EAAE,GAAGY,EAApB,EAAwBZ,EAAE,GAAGA,EAAE,GAAGe,EAAlC,EACAX,GADA,CACIJ,EAAE,GAAGkB,EADT,EACalB,EAAE,GAAG,CAACmB,EADnB,EACuBnB,EADvB,EAC2BA,EAD3B,EAC+BqB,KAD/B,EAEAQ,IAFA,CAEKT,EAAE,GAAGN,EAFV,EAEcM,EAAE,GAAG,CAACH,EAFpB;AAGD,OAJD,MAIO;AACLf,QAAAA,IAAI,CAACA,IAAL,CAAU4B,IAAV,CAAeR,GAAf,EAAoBC,QAApB,EAA8BC,QAA9B,EAAwCC,EAAxC,EAA4ClB,UAAU,GAAG,GAAb,GAAmBmB,KAA/D,EAAuEnB,UAAU,GAAG,GAAb,GAAmBmB,KAApB,GAA8B,CAAClB,QAAQ,GAAGD,UAAZ,IAA0B,GAA1B,GAAgCmB,KAApI,EAA4I,CAA5I;AACD;;AAED,UAAIzB,EAAJ,EAAQ;AACNC,QAAAA,IAAI,CAACG,UAAL,CAAgBJ,EAAE,GAAG,CAACiB,EAAtB,EAA0BjB,EAAE,GAAGkB,EAA/B,EAAmClB,EAAnC,EAAuCA,EAAvC,EAA2CoB,KAA3C;AACD;;AAED,aAAOnB,IAAP;AACD;;;6BACQ;AAEP,UAAMK,UAAU,GAAG,KAAKf,KAAL,CAAWe,UAA9B;AACA,UAAMC,QAAQ,GAAG,KAAKhB,KAAL,CAAWgB,QAA5B;;AACA,UAAID,UAAU,GAAGC,QAAb,KAA0B,CAA9B,EAAiC;AAC/B;AACD;;AAGD,UAAMuB,WAAW,GAAG,KAAKvC,KAAL,CAAWuC,WAAX,IAA0B,CAA9C;AACA,UAAMC,WAAW,GAAG,KAAKxC,KAAL,CAAWwC,WAA/B;AAGA,UAAM/B,EAAE,GAAGP,IAAI,CAACuC,GAAL,CAASF,WAAT,EAAsBC,WAAtB,CAAX;AACA,UAAMhC,EAAE,GAAGN,IAAI,CAACwC,GAAL,CAASH,WAAT,EAAsBC,WAAtB,CAAX;AAEA,UAAI9B,IAAJ;;AACA,UAAIM,QAAQ,IAAID,UAAU,GAAG,GAA7B,EAAkC;AAChCL,QAAAA,IAAI,GAAG,KAAKiC,iBAAL,CAAuBnC,EAAvB,EAA2BC,EAA3B,CAAP;AACD,OAFD,MAEO;AACLC,QAAAA,IAAI,GAAG,KAAKkC,cAAL,CAAoB7B,UAApB,EAAgCC,QAAhC,EAA0CR,EAA1C,EAA8CC,EAA9C,CAAP;AACD;;AAED,UAAI0B,QAAQ,CAACC,EAAT,KAAgB,KAAhB,IAA0BrB,UAAU,KAAK,CAAf,IAAoBC,QAAQ,IAAI,GAA9D,EAAoE;AAClE,eAAO,oBAAC,KAAD,eAAW,KAAKhB,KAAhB;AAAuB,UAAA,CAAC,EAAEU,IAA1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAAP;AACD,OAFD,MAEO;AACL,YAAImC,IAAI,GAAG,KAAK7C,KAAL,CAAWwC,WAAX,GAAyB,CAApC;AACA,YAAIM,EAAE,GAAGC,EAAE,GAAGF,IAAI,GAAC,CAAnB;AACA,YAAIG,CAAC,GAAGlD,IAAI,EAAZ;AACAkD,QAAAA,CAAC,CAACtC,IAAF,CAAO4B,IAAP,CAAY,CAAZ,EAAeQ,EAAf,EAAmBC,EAAnB;AACAC,QAAAA,CAAC,CAACtC,IAAF,CAAO4B,IAAP,CAAY,CAAZ,EAAeQ,EAAf,EAAmBC,EAAnB,EAAuBP,WAAvB,EAAoCzB,UAAU,GAAGb,IAAI,CAACC,EAAlB,GAAuB,GAA3D,EAAgEa,QAAQ,GAAGd,IAAI,CAACC,EAAhB,GAAqB,GAArF,EAA0F,CAA1F;AACA,eAAO,oBAAC,KAAD;AAAO,UAAA,CAAC,EAAE6C,CAAV;AAAa,UAAA,IAAI,EAAE,KAAKhD,KAAL,CAAWiD,IAA9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAAP;AACD;AACF;;;;EA3JiBvD,S;;AA8JpBK,KAAK,CAACmD,SAAN,GAAkB;AAChBV,EAAAA,WAAW,EAAE5C,SAAS,CAACuD,MAAV,CAAiBC,UADd;AAEhBrC,EAAAA,UAAU,EAAEnB,SAAS,CAACuD,MAAV,CAAiBC,UAFb;AAGhBpC,EAAAA,QAAQ,EAAEpB,SAAS,CAACuD,MAAV,CAAiBC,UAHX;AAIhBb,EAAAA,WAAW,EAAE3C,SAAS,CAACuD;AAJP,CAAlB;AAOA,eAAepD,KAAf","sourcesContent":["/**\n * Copyright (c) 2013-present Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Wedge.art\n * @typechecks\n *\n * Example usage:\n * <Wedge\n *   outerRadius={50}\n *   startAngle={0}\n *   endAngle={360}\n *   fill=\"blue\"\n * />\n *\n * Additional optional property:\n *   (Int) innerRadius\n *\n */\n\nimport React, {Component} from 'react';\nimport {Platform, ART} from 'react-native';\nimport PropTypes from 'prop-types';\nconst {Shape, Path} = ART;\n\n/**\n * Wedge is a React component for drawing circles, wedges and arcs.  Like other\n * ReactART components, it must be used in a <Surface>.\n */\nclass Wedge extends Component {\n  constructor(props) {\n    super(props);\n    this.circleRadians = Math.PI * 2;\n    this.radiansPerDegree = Math.PI / 180;\n    this._degreesToRadians = this._degreesToRadians.bind(this);\n  }\n  /**\n   * degreesToRadians(degrees)\n   *\n   * Helper function to convert degrees to radians\n   *\n   * @param {number} degrees\n   * @return {number}\n   */\n  _degreesToRadians(degrees) {\n    if (degrees !== 0 && degrees % 360 === 0) { // 360, 720, etc.\n      return this.circleRadians;\n    }\n    return degrees * this.radiansPerDegree % this.circleRadians;\n  }\n  /**\n   * createCirclePath(or, ir)\n   *\n   * Creates the ReactART Path for a complete circle.\n   *\n   * @param {number} or The outer radius of the circle\n   * @param {number} ir The inner radius, greater than zero for a ring\n   * @return {object}\n   */\n  _createCirclePath(or, ir) {\n    const path = new Path();\n\n    path.move(0, or).arc(or * 2, 0, or).arc(-or * 2, 0, or);\n\n    if (ir) {\n      path.move(or - ir, 0).counterArc(ir * 2, 0, ir).counterArc(-ir * 2, 0, ir);\n    }\n\n    path.close();\n\n    return path;\n  }\n  /**\n  \t * _createArcPath(sa, ea, ca, or, ir)\n  \t *\n  \t * Creates the ReactART Path for an arc or wedge.\n  \t *\n  \t * @param {number} startAngle The starting degrees relative to 12 o'clock\n  \t * @param {number} endAngle The ending degrees relative to 12 o'clock\n  \t * @param {number} or The outer radius in pixels\n  \t * @param {number} ir The inner radius in pixels, greater than zero for an arc\n  \t * @return {object}\n  \t */\n  _createArcPath(startAngle, endAngle, or, ir) {\n    const path = new Path();\n\n    // angles in radians\n    const sa = this._degreesToRadians(startAngle);\n    const ea = this._degreesToRadians(endAngle);\n\n    // central arc angle in radians\n    const ca = sa > ea\n        ? this.circleRadians - sa + ea\n        : ea - sa;\n\n    // cached sine and cosine values\n    const ss = Math.sin(sa);\n    const es = Math.sin(ea);\n    const sc = Math.cos(sa);\n    const ec = Math.cos(ea);\n\n    // cached differences\n    const ds = es - ss;\n    const dc = ec - sc;\n    const dr = ir - or;\n\n    // if the angle is over pi radians (180 degrees)\n    // we will need to let the drawing method know.\n    const large = ca > Math.PI;\n\n    // TODO (sema) Please improve theses comments to make the math\n    // more understandable.\n    //\n    // Formula for a point on a circle at a specific angle with a center\n    // at (0, 0):\n    // x = radius * Math.sin(radians)\n    // y = radius * Math.cos(radians)\n    //\n    // For our starting point, we offset the formula using the outer\n    // radius because our origin is at (top, left).\n    // In typical web layout fashion, we are drawing in quadrant IV\n    // (a.k.a. Southeast) where x is positive and y is negative.\n    //\n    // The arguments for path.arc and path.counterArc used below are:\n    // (endX, endY, radiusX, radiusY, largeAngle)\n\n    // Update by Gene Xu to fix android issue, follow below\n    // https://github.com/facebook/react-native/blob/master/Libraries/ART/ARTSerializablePath.js\n    // https://github.com/bgryszko/react-native-circular-progress/blob/master/src/CircularProgress.js\n    // https://github.com/nihgwu/react-native-pie\n\n    const ARC = 4;\n    const CIRCLE_X = or;\n    const CIRCLE_Y = or;\n    const RX = or - or / 2;\n    const TwoPI = 2 * Math.PI;\n\n    if (Platform.OS === 'ios' || (startAngle === 0 && endAngle == 360)) {\n      path.move(or + or * ss, or - or * sc). // move to starting point\n      arc(or * ds, or * -dc, or, or, large). // outer arc\n      line(dr * es, dr * -ec); // width of arc or wedge\n    } else {\n      path.path.push(ARC, CIRCLE_X, CIRCLE_Y, RX, startAngle / 360 * TwoPI, (startAngle / 360 * TwoPI) - ((endAngle - startAngle) / 360 * TwoPI), 0)\n    }\n\n    if (ir) {\n      path.counterArc(ir * -ds, ir * dc, ir, ir, large); // inner arc\n    }\n\n    return path;\n  }\n  render() {\n    // angles are provided in degrees\n    const startAngle = this.props.startAngle;\n    const endAngle = this.props.endAngle;\n    if (startAngle - endAngle === 0) {\n      return;\n    }\n\n    // radii are provided in pixels\n    const innerRadius = this.props.innerRadius || 0;\n    const outerRadius = this.props.outerRadius;\n\n    // sorted radii\n    const ir = Math.min(innerRadius, outerRadius);\n    const or = Math.max(innerRadius, outerRadius);\n\n    let path;\n    if (endAngle >= startAngle + 360) {\n      path = this._createCirclePath(or, ir);\n    } else {\n      path = this._createArcPath(startAngle, endAngle, or, ir);\n    }\n\n    if (Platform.OS === 'ios' || (startAngle === 0 && endAngle == 360)) {\n      return <Shape {...this.props} d={path}/>;\n    } else {\n      let size = this.props.outerRadius * 2;\n      let cx = cy = size/2;\n      let p = Path();\n      p.path.push(0, cx, cy);\n      p.path.push(4, cx, cy, outerRadius, startAngle * Math.PI / 180, endAngle * Math.PI / 180, 1);\n      return <Shape d={p} fill={this.props.fill} />;\n    }\n  }\n}\n\nWedge.propTypes = {\n  outerRadius: PropTypes.number.isRequired,\n  startAngle: PropTypes.number.isRequired,\n  endAngle: PropTypes.number.isRequired,\n  innerRadius: PropTypes.number\n};\n\nexport default Wedge;\n"]},"metadata":{},"sourceType":"module"}